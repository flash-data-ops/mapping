<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Mapbox Visualizer</title>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            background: white;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.06), 0 4px 8px rgba(0,0,0,0.03);
            border: 1px solid rgba(0,0,0,0.05);
        }

        .controls-header {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #f1f5f9;
        }

        .controls-header h2 {
            font-size: 1.3rem;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .controls-header h2::before {
            content: '⚙️';
            font-size: 1.1rem;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }

        .control-section {
            background: #f8fafc;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
        }

        .control-section:hover {
            border-color: #cbd5e1;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .control-section h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
            margin: 0 0 12px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group:last-child {
            margin-bottom: 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #374151;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
            color: #1e293b;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .input-group input::placeholder {
            color: #94a3b8;
        }

        .btn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            box-shadow: 0 4px 12px rgba(100, 116, 139, 0.2);
        }

        .btn-secondary:hover {
            box-shadow: 0 8px 20px rgba(100, 116, 139, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
        }

        .btn-danger:hover {
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        .status {
            margin-top: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 13px;
            border-left: 3px solid;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status.success {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            color: #166534;
            border-left-color: #22c55e;
        }

        .status.error {
            background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
            color: #991b1b;
            border-left-color: #ef4444;
        }

        .status.loading {
            background: linear-gradient(135deg, #fefce8 0%, #fef3c7 100%);
            color: #92400e;
            border-left-color: #f59e0b;
        }

        .map-container {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            height: 600px;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .legend {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .legend h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            margin-right: 10px;
            border-radius: 2px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Enhanced popup styling */
        .mapboxgl-popup-content {
            border-radius: 16px !important;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15), 0 10px 20px -5px rgba(0, 0, 0, 0.1) !important;
            border: 1px solid rgba(0, 0, 0, 0.08) !important;
            padding: 0 !important;
            overflow: hidden !important;
            backdrop-filter: blur(10px) !important;
            background: rgba(255, 255, 255, 0.95) !important;
        }

        .mapboxgl-popup-tip {
            border-top-color: rgba(255, 255, 255, 0.95) !important;
            filter: drop-shadow(0 -2px 4px rgba(0, 0, 0, 0.1)) !important;
        }

        .mapboxgl-popup-close-button {
            background: rgba(255, 255, 255, 0.95) !important;
            border-radius: 50% !important;
            width: 30px !important;
            height: 30px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            color: #64748b !important;
            right: 8px !important;
            top: 8px !important;
            padding: 0 !important;
            border: 1px solid rgba(0, 0, 0, 0.15) !important;
            transition: all 0.2s ease !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            z-index: 1000 !important;
            line-height: 1 !important;
            text-decoration: none !important;
            outline: none !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
        }

        .mapboxgl-popup-close-button:hover {
            background: rgba(239, 68, 68, 0.1) !important;
            color: #ef4444 !important;
            border-color: rgba(239, 68, 68, 0.3) !important;
            transform: scale(1.1) !important;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15) !important;
        }

        .mapboxgl-popup-close-button:active {
            transform: scale(0.95) !important;
            transition: transform 0.1s ease !important;
        }

        /* Custom popup content styling */
        .popup-content {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.5;
        }

        .popup-header {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 8px 10px;
            border-bottom: 1px solid #e2e8f0;
            position: relative;
        }

        .popup-title {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 0;
            font-size: 13px;
            font-weight: 700;
            color: #1e293b;
        }

        .popup-icon {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .popup-body {
            padding: 10px;
        }

        .popup-info-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
            margin-bottom: 8px;
        }

        .popup-info-item {
            background: #f8fafc;
            padding: 6px 8px;
            border-radius: 4px;
            border-left: 2px solid #3b82f6;
        }

        .popup-info-label {
            color: #64748b;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 600;
            margin-bottom: 1px;
        }

        .popup-info-value {
            color: #1e293b;
            font-size: 11px;
            font-weight: 600;
        }

        .popup-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 4px;
        }

        .popup-stat-card {
            background: white;
            padding: 6px 4px;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            text-align: center;
            transition: all 0.2s ease;
        }

        .popup-stat-card:hover {
            border-color: #cbd5e1;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .popup-stat-label {
            color: #64748b;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 600;
            margin-bottom: 1px;
        }

        .popup-stat-value {
            color: #1e293b;
            font-size: 10px;
            font-weight: 700;
        }

        .popup-distance-card {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            padding: 6px 4px;
            border-radius: 4px;
            text-align: center;
            box-shadow: 0 1px 4px rgba(59, 130, 246, 0.2);
        }

        .popup-distance-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 600;
            opacity: 0.9;
            margin-bottom: 1px;
        }

        .popup-distance-value {
            font-size: 11px;
            font-weight: 700;
        }

        /* Enhanced select styling */
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
            background-position: right 8px center !important;
            background-repeat: no-repeat !important;
            background-size: 16px !important;
            appearance: none !important;
            padding-right: 35px !important;
        }

        /* Loading animation improvements */
        .loading-spinner {
            animation: spin 1s linear infinite !important;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Enhanced button hover effects */
        .btn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3) !important;
        }

        .btn:active {
            transform: translateY(0) !important;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                padding: 16px;
                margin-bottom: 12px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .control-section {
                padding: 14px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
                margin-right: 0;
                padding: 12px 16px;
            }
            
            .map-container {
                height: 450px;
            }

            .mapboxgl-popup-content {
                max-width: 220px !important;
            }
            
            .popup-header {
                padding: 6px 8px;
            }
            
            .popup-body {
                padding: 8px;
            }
            
            .popup-title {
                font-size: 12px;
            }
            
            .popup-stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 3px;
            }
            
            .popup-info-grid {
                gap: 3px;
                margin-bottom: 6px;
            }
            
            .popup-info-item {
                padding: 4px 6px;
            }
        }

        @media (max-width: 480px) {
            .controls {
                padding: 12px;
            }
            
            .control-section {
                padding: 12px;
            }
            
            .controls-header h2 {
                font-size: 1.2rem;
            }
            
            .map-container {
                height: 400px;
            }
            
            .mapboxgl-popup-content {
                max-width: 200px !important;
            }
            
            .popup-header {
                padding: 5px 6px;
            }
            
            .popup-body {
                padding: 6px;
            }
            
            .popup-title {
                font-size: 11px;
            }
            
            .popup-stats-grid {
                grid-template-columns: 1fr;
                gap: 2px;
            }
            
            .popup-stat-card {
                padding: 4px 3px;
            }
            
            .popup-info-grid {
                gap: 2px;
                margin-bottom: 6px;
            }
            
            .popup-info-item {
                padding: 4px 5px;
            }
            
            .popup-icon {
                width: 8px;
                height: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🗺️ GeoJSON Mapbox Visualizer</h1>
            <p>Visualize GeoJSON data from Control Table - On-Street Data Mapping - Washington DC on interactive Mapbox maps</p>
        </div>

        <div class="controls">
            <!-- Hidden input for sheet URL -->
            <input type="hidden" id="sheetUrl" 
                   value="https://docs.google.com/spreadsheets/d/1gdH0NSk4YqApQ2OEXc_X1LjIu0M6QbSCQ2msucAsLBw/edit?gid=0#gid=0">
            
            <div class="controls-header">
                <h2>Map Controls</h2>
            </div>
            
            <div class="controls-grid">
                <!-- Search Section -->
                <div class="control-section">
                    <h3>🔍 Search & Filter</h3>
                    <div class="input-group">
                        <label for="searchObjectId">Object ID Search</label>
                        <input type="text" id="searchObjectId" placeholder="Enter Object ID to search..." 
                               onkeypress="handleSearchKeyPress(event)" oninput="searchObjectId()">
                    </div>
                    
                    <div class="input-group">
                        <label for="filterMapper">Filter by Mapper</label>
                        <select id="filterMapper" onchange="applyFilters()">
                            <option value="">All Mappers</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="filterZone">Filter by Zone</label>
                        <select id="filterZone" onchange="applyFilters()">
                            <option value="">All Zones</option>
                        </select>
                    </div>
                </div>
                
                <!-- Data Management Section -->
                <div class="control-section">
                    <h3>📊 Data Management</h3>
                    <div class="button-group">
                        <button class="btn" onclick="loadGeoJSONData()">
                            <span>🔄</span>
                            <span id="loadBtnText">Refresh Data</span>
                        </button>
                        
                        <button class="btn btn-danger" onclick="clearMap()" id="clearBtn" disabled>
                            <span>🗑️</span>
                            <span>Clear Map</span>
                        </button>
                        
                        <button class="btn btn-secondary" onclick="clearFilters()">
                            <span>🧹</span>
                            <span>Clear Filters</span>
                        </button>
                    </div>
                </div>
                
                <!-- Map Settings Section -->
                <div class="control-section">
                    <h3>🗺️ Map Settings</h3>
                    <div class="input-group">
                        <label for="mapStyle">Map Style</label>
                        <select id="mapStyle" onchange="changeMapStyle()">
                            <option value="streets-v12">🗺️ Streets</option>
                            <option value="satellite-streets-v12">🛰️ Satellite</option>
                            <option value="outdoors-v12">🏔️ Outdoors</option>
                            <option value="light-v11">☀️ Light</option>
                            <option value="dark-v11">🌙 Dark</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div id="status"></div>
        </div>

        <div class="map-container">
            <div id="map"></div>
        </div>

    </div>

    <script>
        let map;
        let loadedFeatures = [];
        let allFeatures = []; // Store all loaded features for filtering
        let currentFilters = {
            mapper: '',
            zone: '',
            searchObjectId: ''
        };

        // Initialize Mapbox
        function initMap() {
            // Set your Mapbox access token here
            mapboxgl.accessToken = 'pk.eyJ1Ijoicm9laS1hcnJpdmUiLCJhIjoiY2tqaWhoOHVlMTl4NTJxbzdtYmFwdHhxbCJ9.GDwBpodE6qv9LR-8Yshsjg'; // Demo token
            
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12', // Mapbox streets style
                center: [-76.985, 38.9], // [lng, lat] format for Mapbox
                zoom: 13,
                antialias: true, // Enable anti-aliasing for smoother lines
                attributionControl: false // We'll add custom attribution
            });

            // Add navigation control (zoom buttons and compass)
            map.addControl(new mapboxgl.NavigationControl({
                visualizePitch: true,
                showZoom: true,
                showCompass: true
            }), 'top-right');

            // Add scale control
            map.addControl(new mapboxgl.ScaleControl({
                maxWidth: 100,
                unit: 'metric'
            }), 'bottom-right');

            // Add fullscreen control
            map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

            // Add custom attribution
            map.addControl(new mapboxgl.AttributionControl({
                compact: true,
                customAttribution: '© GeoJSON Visualizer'
            }), 'bottom-left');

            map.on('load', () => {
                showStatus('Map initialized successfully', 'success');
                
                // Add red arrow icon for line end indicators
                map.loadImage('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8IS0tIFNoYWRvdyBlZmZlY3QgLS0+CiAgPHBhdGggZD0iTTMuNSAxMC41TDE2LjUgMTAuNU0xNi41IDEwLjVMMTIuNSA2LjVNMTYuNSAxMC41TDEyLjUgMTQuNSIgc3Ryb2tlPSIjN2YxZDFkIiBzdHJva2Utd2lkdGg9IjMuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBvcGFjaXR5PSIwLjQiLz4KICA8IS0tIE1haW4gYXJyb3cgLS0+CiAgPHBhdGggZD0iTTMgMTBMMTYgMTBNMTYgMTBMMTIgNk0xNiAxMEwxMiAxNCIgc3Ryb2tlPSIjZWY0NDQ0IiBzdHJva2Utd2lkdGg9IjMuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=', (error, image) => {
                    if (error) throw error;
                    map.addImage('arrow-icon', image);
                });
                
                // Auto-load data after map is loaded
                setTimeout(() => {
                    loadGeoJSONData();
                }, 1000);
            });
        }

        // Calculate distance between coordinates using Haversine formula
        function calculateDistance(coords) {
            if (coords.length < 2) return 0;
            
            let totalDistance = 0;
            
            for (let i = 0; i < coords.length - 1; i++) {
                const [lng1, lat1] = coords[i];
                const [lng2, lat2] = coords[i + 1];
                
                const R = 6371000; // Earth's radius in meters
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;
                
                totalDistance += distance;
            }
            
            return totalDistance;
        }

        // Format distance for display in meters
        function formatDistance(meters) {
            if (meters < 1000) {
                return `${Math.round(meters)} m`;
            } else {
                return `${(meters / 1000).toFixed(2)} km`;
            }
        }

        // Extract Sheet ID from Google Sheets URL
        function extractSheetId(url) {
            const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            return match ? match[1] : null;
        }

        // Show status messages
        function showStatus(message, type = 'loading') {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type}`;
            
            if (type === 'loading') {
                statusDiv.innerHTML = `<div class="loading-spinner"></div>${message}`;
            } else {
                statusDiv.innerHTML = message;
            }
            
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

                // Parse coordinate data from sheet rows
        function parseGeoJSONFromRows(rows) {
            const features = [];
            let headers = [];
            
            console.log('Total rows received:', rows.length);
            console.log('First few rows sample:', rows.slice(0, 3));
            
            rows.forEach((row, rowIndex) => {
                console.log(`\n=== Processing Row ${rowIndex} ===`);
                console.log(`Row ${rowIndex} has ${row.length} cells:`, row);
                
                // Check if this is the header row
                if (rowIndex === 0 && (row.includes('Name') || row.includes('Area') || row.includes('ID'))) {
                    headers = row;
                    console.log('Found header row:', headers);
                    return;
                }
                
                // Extract properties from columns A-D (indices 0-3)
                const properties = {};
                
                if (headers.length > 0) {
                    // Use header names if available
                    for (let i = 0; i < Math.min(4, headers.length); i++) {
                        if (row[i] !== undefined && row[i] !== '') {
                            properties[headers[i]] = row[i];
                        }
                    }
                } else {
                    // Use updated property names based on your sheet structure
                    const propertyNames = ['Mapper Name', 'OBJECTID', 'MOBILEPAY_ZONE', 'Street View Spaces'];
                    for (let i = 0; i < 4; i++) {
                        if (row[i] !== undefined && row[i] !== '') {
                            properties[propertyNames[i]] = row[i];
                        }
                    }
                }
                
                console.log('Extracted properties:', properties);
                
                // Extract coordinates from column E onwards (index 4+)
                // Assuming pairs of coordinates: [lng1, lat1, lng2, lat2, lng3, lat3, ...]
                const coordinates = [];
                
                for (let i = 4; i < row.length; i += 2) {
                    const lng = parseFloat(row[i]);
                    const lat = parseFloat(row[i + 1]);
                    
                    if (!isNaN(lng) && !isNaN(lat)) {
                        coordinates.push([lng, lat]);
                        console.log(`Added coordinate pair: [${lng}, ${lat}]`);
                    }
                }
                
                if (coordinates.length >= 2) {
                    if (coordinates.length === 2) {
                        // For exactly 2 points, create a simple LineString
                        const distance = calculateDistance(coordinates);
                        const formattedDistance = formatDistance(distance);
                        
                        const feature = {
                            type: 'Feature',
                            properties: {
                                ...properties,
                                rowIndex: rowIndex,
                                coordinateCount: coordinates.length,
                                distance: distance,
                                formattedDistance: formattedDistance,
                                description: `${properties['Mapper Name'] || 'Mapper'} - Zone ${properties['MOBILEPAY_ZONE'] || 'Unknown'} (${formattedDistance})`
                            },
                            geometry: {
                                type: 'LineString',
                                coordinates: coordinates
                            }
                        };
                        
                        features.push(feature);
                        console.log(`Created LineString for ${properties['Mapper Name'] || 'Unknown'} with ${coordinates.length} points, distance: ${formattedDistance}`);
                    } else {
                        // For more than 2 points, create separate line segments for each consecutive pair
                        let totalDistance = 0;
                        const lineStrings = [];
                        
                        for (let i = 0; i < coordinates.length - 1; i++) {
                            const segmentCoords = [coordinates[i], coordinates[i + 1]];
                            const segmentDistance = calculateDistance(segmentCoords);
                            totalDistance += segmentDistance;
                            
                            lineStrings.push(segmentCoords);
                        }
                        
                        const formattedDistance = formatDistance(totalDistance);
                        
                        // Create a MultiLineString feature with separate line segments
                        const feature = {
                            type: 'Feature',
                            properties: {
                                ...properties,
                                rowIndex: rowIndex,
                                coordinateCount: coordinates.length,
                                distance: totalDistance,
                                formattedDistance: formattedDistance,
                                segmentCount: lineStrings.length,
                                description: `${properties['Mapper Name'] || 'Mapper'} - Zone ${properties['MOBILEPAY_ZONE'] || 'Unknown'} (${lineStrings.length} segments, ${formattedDistance})`
                            },
                            geometry: {
                                type: 'MultiLineString',
                                coordinates: lineStrings
                            }
                        };
                        
                        features.push(feature);
                        console.log(`Created MultiLineString for ${properties['Mapper Name'] || 'Unknown'} with ${lineStrings.length} separate segments, total distance: ${formattedDistance}`);
                    }
                } else if (coordinates.length === 1) {
                    // Create a Point feature if only one coordinate pair
                    const feature = {
                        type: 'Feature',
                        properties: {
                            ...properties,
                            rowIndex: rowIndex,
                            description: `${properties['Mapper Name'] || 'Mapper'} - Zone ${properties['MOBILEPAY_ZONE'] || 'Unknown'} (Point)`
                        },
                        geometry: {
                            type: 'Point',
                            coordinates: coordinates[0]
                        }
                    };
                    
                    features.push(feature);
                    console.log(`Created Point for ${properties['Mapper Name'] || 'Unknown'}`);
                } else {
                    console.log(`Row ${rowIndex} (${properties['Mapper Name'] || 'Unknown'}): Not enough valid coordinates (found ${coordinates.length})`);
                }
            });
            
            console.log(`Parsing summary: Created ${features.length} features`);
            features.forEach((feature, index) => {
                const props = feature.properties;
                console.log(`Feature ${index}: ${props['Mapper Name']} (Zone ${props['MOBILEPAY_ZONE']}) - ${feature.geometry.type} with ${feature.geometry.type === 'LineString' ? feature.geometry.coordinates.length : 1} points`);
            });
            
            return features;
        }

        // Add GeoJSON features to Mapbox map
        function addFeaturesToMap(features) {
            let featureCount = 0;
            const bounds = new mapboxgl.LngLatBounds();

            // Create GeoJSON FeatureCollection for lines, start points, and end points
            const lineFeatures = [];
            const pointFeatures = [];
            const startPointFeatures = [];
            const endPointFeatures = [];

            features.forEach((feature, index) => {
                if (!feature.geometry || !feature.geometry.coordinates) return;

                const geometry = feature.geometry;

                if (geometry.type === 'LineString' || geometry.type === 'MultiLineString') {
                    lineFeatures.push(feature);
                    
                    // Create start and end point features
                    let startCoord, endCoord;
                    
                    if (geometry.type === 'LineString') {
                        startCoord = geometry.coordinates[0];
                        endCoord = geometry.coordinates[geometry.coordinates.length - 1];
                        
                        geometry.coordinates.forEach(coord => {
                            bounds.extend(coord);
                        });
                    } else if (geometry.type === 'MultiLineString') {
                        // For MultiLineString, use the first point of first line and last point of last line
                        const firstLine = geometry.coordinates[0];
                        const lastLine = geometry.coordinates[geometry.coordinates.length - 1];
                        startCoord = firstLine[0];
                        endCoord = lastLine[lastLine.length - 1];
                        
                        geometry.coordinates.forEach(lineString => {
                            lineString.forEach(coord => {
                                bounds.extend(coord);
                            });
                        });
                    }
                    
                    // Create start point feature
                    if (startCoord) {
                        startPointFeatures.push({
                            type: 'Feature',
                            properties: {
                                ...feature.properties,
                                pointType: 'start'
                            },
                            geometry: {
                                type: 'Point',
                                coordinates: startCoord
                            }
                        });
                    }
                    
                    // Create end point feature
                    if (endCoord) {
                        endPointFeatures.push({
                            type: 'Feature',
                            properties: {
                                ...feature.properties,
                                pointType: 'end'
                            },
                            geometry: {
                                type: 'Point',
                                coordinates: endCoord
                            }
                        });
                    }
                    
                } else if (geometry.type === 'Point') {
                    pointFeatures.push(feature);
                    bounds.extend(geometry.coordinates);
                }
                featureCount++;
            });

            // Add line features as a source and layer
            if (lineFeatures.length > 0) {
                map.addSource('routes', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': lineFeatures
                    }
                });

                // Add route outline (shadow effect)
                map.addLayer({
                    'id': 'routes-outline',
                    'type': 'line',
                    'source': 'routes',
                    'layout': {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    'paint': {
                        'line-color': 'rgba(0, 0, 0, 0.3)',
                        'line-width': 3,
                        'line-opacity': 0.6,
                        'line-blur': 1
                    }
                });

                // Add main route layer with enhanced styling
                map.addLayer({
                    'id': 'routes',
                    'type': 'line',
                    'source': 'routes',
                    'layout': {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    'paint': {
                        'line-color': '#000000', // Black color for all lines
                        'line-width': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 1,
                            15, 2,
                            18, 3
                        ],
                        'line-opacity': 0.9
                    }
                });

                // Add start points as separate source and layers
                map.addSource('start-points', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': startPointFeatures
                    }
                });

                // Add shadow/glow effect for start points
                map.addLayer({
                    'id': 'line-start-points-shadow',
                    'type': 'circle',
                    'source': 'start-points',
                    'paint': {
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 4,  // Shadow larger than main circle
                            18, 6   // Bigger shadow at high zoom
                        ],
                        'circle-color': '#1e40af', // Darker blue for shadow
                        'circle-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 0.3, // Subtle shadow
                            18, 0.4  // Slightly more visible at high zoom
                        ],
                        'circle-blur': 1
                    }
                });

                // Add line start points (enhanced circles at beginning of lines)
                map.addLayer({
                    'id': 'line-start-points',
                    'type': 'circle',
                    'source': 'start-points',
                    'paint': {
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 3,  // Bigger for better visibility
                            18, 4   // Even bigger at high zoom
                        ],
                        'circle-color': '#3b82f6', // Bright blue color
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-width': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            15, 1,   // Thicker stroke at medium zoom
                            18, 1.5  // Even thicker at high zoom
                        ],
                        'circle-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 1,  // Fully visible at medium zoom
                            18, 1   // Fully visible at high zoom
                        ],
                        'circle-stroke-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 0.9, // Visible stroke
                            18, 1   // Fully visible stroke
                        ]
                    }
                });

                // Add end points as separate source and red circles
                map.addSource('end-points', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': endPointFeatures
                    }
                });

                // Add shadow/glow effect for end points
                map.addLayer({
                    'id': 'line-end-points-shadow',
                    'type': 'circle',
                    'source': 'end-points',
                    'paint': {
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 4,  // Shadow larger than main circle
                            18, 6   // Bigger shadow at high zoom
                        ],
                        'circle-color': '#7f1d1d', // Darker red for shadow
                        'circle-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 0.3, // Subtle shadow
                            18, 0.4  // Slightly more visible at high zoom
                        ],
                        'circle-blur': 1
                    }
                });

                // Add line end points (red circles at end of lines)
                map.addLayer({
                    'id': 'line-end-points',
                    'type': 'circle',
                    'source': 'end-points',
                    'paint': {
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 3,  // Bigger for better visibility
                            18, 4   // Even bigger at high zoom
                        ],
                        'circle-color': '#ef4444', // Bright red color
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-width': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            15, 1,   // Thicker stroke at medium zoom
                            18, 1.5  // Even thicker at high zoom
                        ],
                        'circle-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 1,  // Fully visible at medium zoom
                            18, 1   // Fully visible at high zoom
                        ],
                        'circle-stroke-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 0,  // Invisible at low zoom
                            15, 0.9, // Visible stroke
                            18, 1   // Fully visible stroke
                        ]
                    }
                });

                // Gap visualization removed for multi-line strings

                // Add click handler for lines with enhanced popup styling
                map.on('click', 'routes', (e) => {
                    const props = e.features[0].properties;
                    const geometryType = e.features[0].geometry.type;
                    const isMultiSegment = props.segmentCount > 1;
                    const routeColor = isMultiSegment ? '#16a34a' : '#2563eb';
                    
                    const content = `
                        <div class="popup-content">
                            <div class="popup-header">
                                <h3 class="popup-title">
                                    <div class="popup-icon" style="background: ${routeColor};"></div>
                                    ${props['Mapper Name'] || 'Mapper'}
                                </h3>
                            </div>
                            <div class="popup-body">
                                <div class="popup-info-grid">
                                    ${props['OBJECTID'] ? `
                                    <div class="popup-info-item">
                                        <div class="popup-info-label">Object ID</div>
                                        <div class="popup-info-value">${props['OBJECTID']}</div>
                                    </div>` : ''}
                                    ${props['MOBILEPAY_ZONE'] ? `
                                    <div class="popup-info-item">
                                        <div class="popup-info-label">Mobile Pay Zone</div>
                                        <div class="popup-info-value">${props['MOBILEPAY_ZONE']}</div>
                                    </div>` : ''}
                                    ${props['Street View Spaces'] ? `
                                    <div class="popup-info-item">
                                        <div class="popup-info-label">Street View Spaces</div>
                                        <div class="popup-info-value">${props['Street View Spaces']}</div>
                                    </div>` : ''}
                                </div>
                                <div class="popup-stats-grid">
                                    <div class="popup-stat-card">
                                        <div class="popup-stat-label">Type</div>
                                        <div class="popup-stat-value">${geometryType === 'MultiLineString' ? 'Multi-segment' : 'Simple'}</div>
                                    </div>
                                    <div class="popup-stat-card">
                                        <div class="popup-stat-label">Points</div>
                                        <div class="popup-stat-value">${props.coordinateCount || 'N/A'}</div>
                                    </div>
                                    ${props.segmentCount ? `
                                    <div class="popup-stat-card">
                                        <div class="popup-stat-label">Segments</div>
                                        <div class="popup-stat-value">${props.segmentCount}</div>
                                    </div>` : ''}
                                    ${props.formattedDistance ? `
                                    <div class="popup-distance-card">
                                        <div class="popup-distance-label">Distance</div>
                                        <div class="popup-distance-value">${props.formattedDistance}</div>
                                    </div>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    const popup = new mapboxgl.Popup({
                        closeButton: true,
                        closeOnClick: false,
                        closeOnMove: false,
                        maxWidth: '260px',
                        className: 'custom-popup'
                    })
                        .setLngLat(e.lngLat)
                        .setHTML(content)
                        .addTo(map);
                    
                    // Ensure close button is properly clickable
                    setTimeout(() => {
                        const closeButton = popup.getElement().querySelector('.mapboxgl-popup-close-button');
                        if (closeButton) {
                            closeButton.addEventListener('click', (event) => {
                                event.stopPropagation();
                                popup.remove();
                            });
                        }
                    }, 10);
                });

                // Change cursor on hover
                map.on('mouseenter', 'routes', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });

                map.on('mouseleave', 'routes', () => {
                    map.getCanvas().style.cursor = '';
                });
            }

            // Add point features as enhanced markers
            pointFeatures.forEach((feature, index) => {
                const marker = new mapboxgl.Marker({
                    color: '#dc2626',
                    scale: 1.2
                })
                .setLngLat(feature.geometry.coordinates)
                .setPopup(new mapboxgl.Popup({
                    closeButton: true,
                    closeOnClick: false,
                    closeOnMove: false,
                    maxWidth: '220px',
                    className: 'custom-popup'
                }).setHTML(`
                    <div class="popup-content">
                        <div class="popup-header">
                            <h3 class="popup-title">
                                <div class="popup-icon" style="background: #dc2626; border-radius: 50%;"></div>
                                ${feature.properties['Mapper Name'] || 'Mapper'}
                            </h3>
                        </div>
                        <div class="popup-body">
                            <div class="popup-info-grid">
                                ${feature.properties['OBJECTID'] ? `
                                <div class="popup-info-item" style="border-left-color: #dc2626;">
                                    <div class="popup-info-label">Object ID</div>
                                    <div class="popup-info-value">${feature.properties['OBJECTID']}</div>
                                </div>` : ''}
                                ${feature.properties['MOBILEPAY_ZONE'] ? `
                                <div class="popup-info-item" style="border-left-color: #dc2626;">
                                    <div class="popup-info-label">Mobile Pay Zone</div>
                                    <div class="popup-info-value">${feature.properties['MOBILEPAY_ZONE']}</div>
                                </div>` : ''}
                                ${feature.properties['Street View Spaces'] ? `
                                <div class="popup-info-item" style="border-left-color: #dc2626;">
                                    <div class="popup-info-label">Street View Spaces</div>
                                    <div class="popup-info-value">${feature.properties['Street View Spaces']}</div>
                                </div>` : ''}
                            </div>
                            <div class="popup-stats-grid">
                                <div class="popup-distance-card" style="background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);">
                                    <div class="popup-distance-label">Type</div>
                                    <div class="popup-distance-value">📍 Point Location</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `))
                .addTo(map);
                
                loadedFeatures.push(marker);
            });

            // Fit map to show all features with improved animation
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, {
                    padding: { top: 60, bottom: 60, left: 60, right: 60 },
                    maxZoom: 16,
                    duration: 1500, // Smooth animation
                    essential: true // Animation won't be interrupted
                });
            }

            return featureCount;
        }

        // Load GeoJSON data from Google Sheets
        async function loadGeoJSONData() {
            const sheetUrl = document.getElementById('sheetUrl').value;
            const loadBtn = document.querySelector('.btn');
            const loadBtnText = document.getElementById('loadBtnText');
            
            if (!sheetUrl) {
                showStatus('Please enter a Google Sheets URL', 'error');
                return;
            }

            const sheetId = extractSheetId(sheetUrl);
            if (!sheetId) {
                showStatus('Invalid Google Sheets URL', 'error');
                return;
            }

            try {
                loadBtn.disabled = true;
                loadBtnText.innerHTML = '<div class="loading-spinner"></div>Loading...';
                showStatus('Fetching data from Google Sheets...', 'loading');

                // Clear existing features
                clearMap();

                // Google Sheets CSV export URL
                const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
                console.log('Fetching from URL:', csvUrl);
                
                const response = await fetch(csvUrl);
                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                if (!response.ok) {
                    throw new Error(`Failed to fetch data: ${response.status}`);
                }

                const csvText = await response.text();
                console.log('Raw CSV data (first 1000 chars):', csvText.substring(0, 1000));
                console.log('CSV length:', csvText.length);
                
                // Check if we actually got CSV data or an error page
                if (csvText.includes('<html>') || csvText.includes('<!DOCTYPE')) {
                    throw new Error('Received HTML instead of CSV data. Make sure the Google Sheet is publicly accessible.');
                }
                
                // Parse CSV with better handling and performance optimization
                const rows = csvText.split('\n').map((row, rowIndex) => {
                    if (!row.trim()) return []; // Skip empty rows
                    
                    console.log(`Raw row ${rowIndex}:`, row);
                    
                    // Simple CSV parsing (handles basic cases)
                    const cells = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let i = 0; i < row.length; i++) {
                        const char = row[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            cells.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    cells.push(current.trim());
                    
                    console.log(`CSV Row ${rowIndex} parsed into ${cells.length} cells:`, cells);
                    return cells.filter(cell => cell.length > 0); // Remove empty cells
                }).filter(row => row.length > 0); // Remove empty rows
                
                console.log(`Total rows after filtering: ${rows.length}`);
                console.log('Sample of first few rows:', rows.slice(0, 3));

                showStatus('Parsing GeoJSON data...', 'loading');
                
                const features = parseGeoJSONFromRows(rows);
                
                if (features.length === 0) {
                    showStatus('No valid GeoJSON features found in the sheet', 'error');
                    return;
                }

                // Store all features for filtering
                allFeatures = features;
                
                // Populate filter dropdowns
                populateFilters(features);

                showStatus('Adding features to map...', 'loading');
                
                const featureCount = addFeaturesToMap(features);
                
                showStatus(`Successfully loaded ${featureCount} features!`, 'success');
                
                document.getElementById('clearBtn').disabled = false;

            } catch (error) {
                console.error('Error loading data:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                loadBtn.disabled = false;
                loadBtnText.textContent = 'Load & Visualize Data';
            }
        }

        // Clear all features from Mapbox map
        function clearMap() {
            // Remove markers
            loadedFeatures.forEach(marker => {
                marker.remove();
            });
            loadedFeatures = [];
            allFeatures = [];
            
            // Remove line layers and sources
            if (map.getLayer('routes')) {
                map.removeLayer('routes');
            }
            if (map.getLayer('routes-outline')) {
                map.removeLayer('routes-outline');
            }
            if (map.getLayer('line-start-points')) {
                map.removeLayer('line-start-points');
            }
            if (map.getLayer('line-start-points-shadow')) {
                map.removeLayer('line-start-points-shadow');
            }
            if (map.getLayer('line-end-points')) {
                map.removeLayer('line-end-points');
            }
            if (map.getLayer('line-end-points-shadow')) {
                map.removeLayer('line-end-points-shadow');
            }
            if (map.getSource('routes')) {
                map.removeSource('routes');
            }
            if (map.getSource('start-points')) {
                map.removeSource('start-points');
            }
            if (map.getSource('end-points')) {
                map.removeSource('end-points');
            }
            
            // Clear filters
            document.getElementById('filterMapper').innerHTML = '<option value="">All Mappers</option>';
            document.getElementById('filterZone').innerHTML = '<option value="">All Zones</option>';
            document.getElementById('searchObjectId').value = '';
            
            currentFilters = {
                mapper: '',
                zone: '',
                searchObjectId: ''
            };
            
            document.getElementById('clearBtn').disabled = true;
        }

        // Handle Enter key in input
        document.getElementById('sheetUrl').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loadGeoJSONData();
            }
        });

        // Populate filter dropdowns
        function populateFilters(features) {
            const mappers = new Set();
            const zones = new Set();
            
            // Create a mapping of mappers to their zones
            window.mapperZoneMap = {};
            
            features.forEach(feature => {
                const props = feature.properties;
                const mapper = props['Mapper Name'];
                const zone = props['MOBILEPAY_ZONE'];
                
                if (mapper) {
                    mappers.add(mapper);
                    if (!window.mapperZoneMap[mapper]) {
                        window.mapperZoneMap[mapper] = new Set();
                    }
                    if (zone) {
                        window.mapperZoneMap[mapper].add(zone);
                    }
                }
                if (zone) zones.add(zone);
            });
            
            // Store all zones for reference
            window.allZones = Array.from(zones).sort((a, b) => a - b);
            
            // Populate mapper dropdown
            const mapperSelect = document.getElementById('filterMapper');
            mapperSelect.innerHTML = '<option value="">All Mappers</option>';
            Array.from(mappers).sort().forEach(mapper => {
                const option = document.createElement('option');
                option.value = mapper;
                option.textContent = mapper;
                mapperSelect.appendChild(option);
            });
            
            // Populate zone dropdown with all zones initially
            populateZoneDropdown();
        }
        
        // Populate zone dropdown based on selected mapper
        function populateZoneDropdown(selectedMapper = null) {
            const zoneSelect = document.getElementById('filterZone');
            const currentZoneValue = zoneSelect.value; // Remember current selection
            zoneSelect.innerHTML = '<option value="">All Zones</option>';
            
            let zonesToShow;
            if (selectedMapper && window.mapperZoneMap && window.mapperZoneMap[selectedMapper]) {
                // Show only zones for the selected mapper
                zonesToShow = Array.from(window.mapperZoneMap[selectedMapper]).sort((a, b) => a - b);
            } else {
                // Show all zones
                zonesToShow = window.allZones || [];
            }
            
            zonesToShow.forEach(zone => {
                const option = document.createElement('option');
                option.value = zone;
                option.textContent = zone;
                zoneSelect.appendChild(option);
            });
            
            // Try to restore the previous zone selection if it's still available
            if (currentZoneValue && zonesToShow.includes(currentZoneValue)) {
                zoneSelect.value = currentZoneValue;
            } else if (currentZoneValue && selectedMapper) {
                // If the previously selected zone is not available for this mapper, clear the zone filter
                zoneSelect.value = '';
                // Update the current filters
                currentFilters.zone = '';
            }
        }

        // Filter features based on current filters
        function getFilteredFeatures() {
            return allFeatures.filter(feature => {
                const props = feature.properties;
                
                // Mapper filter
                if (currentFilters.mapper && props['Mapper Name'] !== currentFilters.mapper) {
                    return false;
                }
                
                // Zone filter
                if (currentFilters.zone && props['MOBILEPAY_ZONE'] !== currentFilters.zone) {
                    return false;
                }
                
                // Object ID search
                if (currentFilters.searchObjectId && 
                    !props['OBJECTID'].toString().includes(currentFilters.searchObjectId)) {
                    return false;
                }
                
                return true;
            });
        }

        // Apply filters to map
        function applyFilters() {
            const selectedMapper = document.getElementById('filterMapper').value;
            const previousMapper = currentFilters.mapper;
            
            currentFilters.mapper = selectedMapper;
            currentFilters.zone = document.getElementById('filterZone').value;
            
            // If mapper selection changed, update zone dropdown
            if (selectedMapper !== previousMapper) {
                populateZoneDropdown(selectedMapper);
                // Update zone filter value after dropdown is populated
                currentFilters.zone = document.getElementById('filterZone').value;
            }
            
            updateMapWithFilters();
        }

        // Search for Object ID
        function searchObjectId() {
            currentFilters.searchObjectId = document.getElementById('searchObjectId').value.trim();
            updateMapWithFilters();
        }

        // Handle Enter key press in search
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchObjectId();
            }
        }

        // Update map with filtered features
        function updateMapWithFilters() {
            // Clear existing features
            clearMapFeatures();
            
            // Get filtered features
            const filteredFeatures = getFilteredFeatures();
            
            // Add filtered features to map
            if (filteredFeatures.length > 0) {
                addFeaturesToMap(filteredFeatures);
                showStatus(`Showing ${filteredFeatures.length} of ${allFeatures.length} features`, 'success');
                document.getElementById('clearBtn').disabled = false;
            } else {
                showStatus('No features match the current filters', 'error');
            }
        }

        // Clear only map features (for filtering), not the filter dropdowns
        function clearMapFeatures() {
            // Remove markers
            loadedFeatures.forEach(marker => {
                marker.remove();
            });
            loadedFeatures = [];
            
            // Remove line layers and sources
            if (map.getLayer('routes')) {
                map.removeLayer('routes');
            }
            if (map.getLayer('routes-outline')) {
                map.removeLayer('routes-outline');
            }
            if (map.getLayer('line-start-points')) {
                map.removeLayer('line-start-points');
            }
            if (map.getLayer('line-start-points-shadow')) {
                map.removeLayer('line-start-points-shadow');
            }
            if (map.getLayer('line-end-points')) {
                map.removeLayer('line-end-points');
            }
            if (map.getLayer('line-end-points-shadow')) {
                map.removeLayer('line-end-points-shadow');
            }
            if (map.getSource('routes')) {
                map.removeSource('routes');
            }
            if (map.getSource('start-points')) {
                map.removeSource('start-points');
            }
            if (map.getSource('end-points')) {
                map.removeSource('end-points');
            }
        }

        // Clear all filters
        function clearFilters() {
            document.getElementById('filterMapper').value = '';
            document.getElementById('filterZone').value = '';
            document.getElementById('searchObjectId').value = '';
            
            // Reset zone dropdown to show all zones
            populateZoneDropdown();
            
            currentFilters = {
                mapper: '',
                zone: '',
                searchObjectId: ''
            };
            
            // Show all features
            if (allFeatures.length > 0) {
                clearMapFeatures();
                addFeaturesToMap(allFeatures);
                showStatus(`Showing all ${allFeatures.length} features`, 'success');
            }
        }

        // Change map style
        function changeMapStyle() {
            const styleSelect = document.getElementById('mapStyle');
            const selectedStyle = styleSelect.value;
            map.setStyle(`mapbox://styles/mapbox/${selectedStyle}`);
            
            // Re-add data sources and layers after style change
            map.once('styledata', () => {
                if (allFeatures.length > 0) {
                    // Small delay to ensure style is fully loaded
                    setTimeout(() => {
                        updateMapWithFilters();
                    }, 100);
                }
            });
        }

        // Initialize map when DOM is loaded
        document.addEventListener('DOMContentLoaded', initMap);
    </script>

    <!-- Mapbox GL JS -->
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
</body>
</html>
