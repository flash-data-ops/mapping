<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Mapbox Visualizer</title>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .input-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin-right: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            font-weight: 500;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .map-container {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            height: 600px;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .legend {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .legend h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            margin-right: 10px;
            border-radius: 2px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom popup styling */
        .mapboxgl-popup-content {
            border-radius: 12px !important;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04) !important;
            border: 1px solid rgba(0, 0, 0, 0.05) !important;
            padding: 0 !important;
            overflow: hidden !important;
        }

        .mapboxgl-popup-tip {
            border-top-color: white !important;
        }

        .mapboxgl-popup-close-button {
            background: rgba(0, 0, 0, 0.05) !important;
            border-radius: 50% !important;
            width: 24px !important;
            height: 24px !important;
            font-size: 16px !important;
            color: #64748b !important;
            right: 8px !important;
            top: 8px !important;
            padding: 0 !important;
        }

        .mapboxgl-popup-close-button:hover {
            background: rgba(0, 0, 0, 0.1) !important;
            color: #1e293b !important;
        }

        /* Enhanced select styling */
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
            background-position: right 8px center !important;
            background-repeat: no-repeat !important;
            background-size: 16px !important;
            appearance: none !important;
            padding-right: 35px !important;
        }

        /* Loading animation improvements */
        .loading-spinner {
            animation: spin 1s linear infinite !important;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Enhanced button hover effects */
        .btn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3) !important;
        }

        .btn:active {
            transform: translateY(0) !important;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                padding: 20px;
            }
            
            .map-container {
                height: 400px;
            }

            .mapboxgl-popup-content {
                max-width: 280px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è GeoJSON Mapbox Visualizer</h1>
            <p>Visualize GeoJSON data from Control Table - On-Street Data Mapping - Washington DC on interactive Mapbox maps</p>
        </div>

        <div class="controls">
            <!-- Hidden input for sheet URL -->
            <input type="hidden" id="sheetUrl" 
                   value="https://docs.google.com/spreadsheets/d/1gdH0NSk4YqApQ2OEXc_X1LjIu0M6QbSCQ2msucAsLBw/edit?gid=0#gid=0">
            
            <div class="input-group">
                <label for="searchObjectId">Search Object ID:</label>
                <input type="text" id="searchObjectId" placeholder="Enter Object ID to search..." 
                       onkeypress="handleSearchKeyPress(event)" oninput="searchObjectId()">
            </div>
            
            <div class="input-group">
                <label for="filterMapper">Filter by Mapper:</label>
                <select id="filterMapper" onchange="applyFilters()">
                    <option value="">All Mappers</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="filterZone">Filter by Zone:</label>
                <select id="filterZone" onchange="applyFilters()">
                    <option value="">All Zones</option>
                </select>
            </div>
            
            <button class="btn" onclick="loadGeoJSONData()">
                <span id="loadBtnText">Refresh Data</span>
            </button>
            
            <button class="btn" onclick="clearMap()" id="clearBtn" disabled>Clear Map</button>
            
            <button class="btn" onclick="clearFilters()">Clear Filters</button>
            
            <div class="input-group">
                <label for="mapStyle">Map Style:</label>
                <select id="mapStyle" onchange="changeMapStyle()">
                    <option value="streets-v12">Streets</option>
                    <option value="satellite-streets-v12">Satellite</option>
                    <option value="outdoors-v12">Outdoors</option>
                    <option value="light-v11">Light</option>
                    <option value="dark-v11">Dark</option>
                </select>
            </div>
            
            <div id="status"></div>
        </div>

        <div class="map-container">
            <div id="map"></div>
        </div>

        <div class="legend" id="legend" style="display: none;">
            <h3>üó∫Ô∏è Map Legend</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #2563eb; box-shadow: 0 0 4px rgba(37, 99, 235, 0.3);"></div>
                <span>Simple Routes (2 points)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #16a34a; box-shadow: 0 0 4px rgba(22, 163, 74, 0.3);"></div>
                <span>Multi-segment Routes</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #dc2626; border-radius: 50%; width: 12px; height: 12px;"></div>
                <span>Point Locations</span>
            </div>
        </div>
    </div>

    <script>
        let map;
        let loadedFeatures = [];
        let allFeatures = []; // Store all loaded features for filtering
        let currentFilters = {
            mapper: '',
            zone: '',
            searchObjectId: ''
        };

        // Initialize Mapbox
        function initMap() {
            // Set your Mapbox access token here
            mapboxgl.accessToken = 'pk.eyJ1Ijoicm9laS1hcnJpdmUiLCJhIjoiY2tqaWhoOHVlMTl4NTJxbzdtYmFwdHhxbCJ9.GDwBpodE6qv9LR-8Yshsjg'; // Demo token
            
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12', // Mapbox streets style
                center: [-76.985, 38.9], // [lng, lat] format for Mapbox
                zoom: 13,
                antialias: true, // Enable anti-aliasing for smoother lines
                attributionControl: false // We'll add custom attribution
            });

            // Add navigation control (zoom buttons and compass)
            map.addControl(new mapboxgl.NavigationControl({
                visualizePitch: true,
                showZoom: true,
                showCompass: true
            }), 'top-right');

            // Add scale control
            map.addControl(new mapboxgl.ScaleControl({
                maxWidth: 100,
                unit: 'metric'
            }), 'bottom-right');

            // Add fullscreen control
            map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

            // Add custom attribution
            map.addControl(new mapboxgl.AttributionControl({
                compact: true,
                customAttribution: '¬© GeoJSON Visualizer'
            }), 'bottom-left');

            map.on('load', () => {
                showStatus('Map initialized successfully', 'success');
                
                // Auto-load data after map is loaded
                setTimeout(() => {
                    loadGeoJSONData();
                }, 1000);
            });
        }

        // Calculate distance between coordinates using Haversine formula
        function calculateDistance(coords) {
            if (coords.length < 2) return 0;
            
            let totalDistance = 0;
            
            for (let i = 0; i < coords.length - 1; i++) {
                const [lng1, lat1] = coords[i];
                const [lng2, lat2] = coords[i + 1];
                
                const R = 6371000; // Earth's radius in meters
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;
                
                totalDistance += distance;
            }
            
            return totalDistance;
        }

        // Format distance for display in meters
        function formatDistance(meters) {
            if (meters < 1000) {
                return `${Math.round(meters)} m`;
            } else {
                return `${(meters / 1000).toFixed(2)} km`;
            }
        }

        // Extract Sheet ID from Google Sheets URL
        function extractSheetId(url) {
            const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            return match ? match[1] : null;
        }

        // Show status messages
        function showStatus(message, type = 'loading') {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type}`;
            
            if (type === 'loading') {
                statusDiv.innerHTML = `<div class="loading-spinner"></div>${message}`;
            } else {
                statusDiv.innerHTML = message;
            }
            
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

                // Parse coordinate data from sheet rows
        function parseGeoJSONFromRows(rows) {
            const features = [];
            let headers = [];
            
            console.log('Total rows received:', rows.length);
            console.log('First few rows sample:', rows.slice(0, 3));
            
            rows.forEach((row, rowIndex) => {
                console.log(`\n=== Processing Row ${rowIndex} ===`);
                console.log(`Row ${rowIndex} has ${row.length} cells:`, row);
                
                // Check if this is the header row
                if (rowIndex === 0 && (row.includes('Name') || row.includes('Area') || row.includes('ID'))) {
                    headers = row;
                    console.log('Found header row:', headers);
                    return;
                }
                
                // Extract properties from columns A-D (indices 0-3)
                const properties = {};
                
                if (headers.length > 0) {
                    // Use header names if available
                    for (let i = 0; i < Math.min(4, headers.length); i++) {
                        if (row[i] !== undefined && row[i] !== '') {
                            properties[headers[i]] = row[i];
                        }
                    }
                } else {
                    // Use updated property names based on your sheet structure
                    const propertyNames = ['Mapper Name', 'OBJECTID', 'MOBILEPAY_ZONE', 'Street View Spaces'];
                    for (let i = 0; i < 4; i++) {
                        if (row[i] !== undefined && row[i] !== '') {
                            properties[propertyNames[i]] = row[i];
                        }
                    }
                }
                
                console.log('Extracted properties:', properties);
                
                // Extract coordinates from column E onwards (index 4+)
                // Assuming pairs of coordinates: [lng1, lat1, lng2, lat2, lng3, lat3, ...]
                const coordinates = [];
                
                for (let i = 4; i < row.length; i += 2) {
                    const lng = parseFloat(row[i]);
                    const lat = parseFloat(row[i + 1]);
                    
                    if (!isNaN(lng) && !isNaN(lat)) {
                        coordinates.push([lng, lat]);
                        console.log(`Added coordinate pair: [${lng}, ${lat}]`);
                    }
                }
                
                if (coordinates.length >= 2) {
                    if (coordinates.length === 2) {
                        // For exactly 2 points, create a simple LineString
                        const distance = calculateDistance(coordinates);
                        const formattedDistance = formatDistance(distance);
                        
                        const feature = {
                            type: 'Feature',
                            properties: {
                                ...properties,
                                rowIndex: rowIndex,
                                coordinateCount: coordinates.length,
                                distance: distance,
                                formattedDistance: formattedDistance,
                                description: `${properties['Mapper Name'] || 'Mapper'} - Zone ${properties['MOBILEPAY_ZONE'] || 'Unknown'} (${formattedDistance})`
                            },
                            geometry: {
                                type: 'LineString',
                                coordinates: coordinates
                            }
                        };
                        
                        features.push(feature);
                        console.log(`Created LineString for ${properties['Mapper Name'] || 'Unknown'} with ${coordinates.length} points, distance: ${formattedDistance}`);
                    } else {
                        // For more than 2 points, create separate line segments for each consecutive pair
                        let totalDistance = 0;
                        const lineStrings = [];
                        
                        for (let i = 0; i < coordinates.length - 1; i++) {
                            const segmentCoords = [coordinates[i], coordinates[i + 1]];
                            const segmentDistance = calculateDistance(segmentCoords);
                            totalDistance += segmentDistance;
                            
                            lineStrings.push(segmentCoords);
                        }
                        
                        const formattedDistance = formatDistance(totalDistance);
                        
                        // Create a MultiLineString feature with separate line segments
                        const feature = {
                            type: 'Feature',
                            properties: {
                                ...properties,
                                rowIndex: rowIndex,
                                coordinateCount: coordinates.length,
                                distance: totalDistance,
                                formattedDistance: formattedDistance,
                                segmentCount: lineStrings.length,
                                description: `${properties['Mapper Name'] || 'Mapper'} - Zone ${properties['MOBILEPAY_ZONE'] || 'Unknown'} (${lineStrings.length} segments, ${formattedDistance})`
                            },
                            geometry: {
                                type: 'MultiLineString',
                                coordinates: lineStrings
                            }
                        };
                        
                        features.push(feature);
                        console.log(`Created MultiLineString for ${properties['Mapper Name'] || 'Unknown'} with ${lineStrings.length} separate segments, total distance: ${formattedDistance}`);
                    }
                } else if (coordinates.length === 1) {
                    // Create a Point feature if only one coordinate pair
                    const feature = {
                        type: 'Feature',
                        properties: {
                            ...properties,
                            rowIndex: rowIndex,
                            description: `${properties['Mapper Name'] || 'Mapper'} - Zone ${properties['MOBILEPAY_ZONE'] || 'Unknown'} (Point)`
                        },
                        geometry: {
                            type: 'Point',
                            coordinates: coordinates[0]
                        }
                    };
                    
                    features.push(feature);
                    console.log(`Created Point for ${properties['Mapper Name'] || 'Unknown'}`);
                } else {
                    console.log(`Row ${rowIndex} (${properties['Mapper Name'] || 'Unknown'}): Not enough valid coordinates (found ${coordinates.length})`);
                }
            });
            
            console.log(`Parsing summary: Created ${features.length} features`);
            features.forEach((feature, index) => {
                const props = feature.properties;
                console.log(`Feature ${index}: ${props['Mapper Name']} (Zone ${props['MOBILEPAY_ZONE']}) - ${feature.geometry.type} with ${feature.geometry.type === 'LineString' ? feature.geometry.coordinates.length : 1} points`);
            });
            
            return features;
        }

        // Add GeoJSON features to Mapbox map
        function addFeaturesToMap(features) {
            let featureCount = 0;
            const bounds = new mapboxgl.LngLatBounds();

            // Create GeoJSON FeatureCollection for lines
            const lineFeatures = [];
            const pointFeatures = [];

            features.forEach((feature, index) => {
                if (!feature.geometry || !feature.geometry.coordinates) return;

                const geometry = feature.geometry;

                if (geometry.type === 'LineString' || geometry.type === 'MultiLineString') {
                    lineFeatures.push(feature);
                    
                    // Extend bounds for LineString
                    if (geometry.type === 'LineString') {
                        geometry.coordinates.forEach(coord => {
                            bounds.extend(coord);
                        });
                    } else if (geometry.type === 'MultiLineString') {
                        geometry.coordinates.forEach(lineString => {
                            lineString.forEach(coord => {
                                bounds.extend(coord);
                            });
                        });
                    }
                } else if (geometry.type === 'Point') {
                    pointFeatures.push(feature);
                    bounds.extend(geometry.coordinates);
                }
                featureCount++;
            });

            // Add line features as a source and layer
            if (lineFeatures.length > 0) {
                map.addSource('routes', {
                    'type': 'geojson',
                    'data': {
                        'type': 'FeatureCollection',
                        'features': lineFeatures
                    }
                });

                // Add route outline (shadow effect)
                map.addLayer({
                    'id': 'routes-outline',
                    'type': 'line',
                    'source': 'routes',
                    'layout': {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    'paint': {
                        'line-color': 'rgba(0, 0, 0, 0.3)',
                        'line-width': 7,
                        'line-opacity': 0.6,
                        'line-blur': 2
                    }
                });

                // Add main route layer with enhanced styling
                map.addLayer({
                    'id': 'routes',
                    'type': 'line',
                    'source': 'routes',
                    'layout': {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    'paint': {
                        'line-color': [
                            'case',
                            ['==', ['get', 'segmentCount'], null], '#2563eb', // Simple routes - blue
                            '#16a34a' // Multi-segment routes - green
                        ],
                        'line-width': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            10, 3,
                            15, 5,
                            18, 8
                        ],
                        'line-opacity': 0.9
                    }
                });

                // Gap visualization removed for multi-line strings

                // Add click handler for lines with enhanced popup styling
                map.on('click', 'routes', (e) => {
                    const props = e.features[0].properties;
                    const geometryType = e.features[0].geometry.type;
                    const isMultiSegment = props.segmentCount > 1;
                    const routeColor = isMultiSegment ? '#16a34a' : '#2563eb';
                    
                    const content = `
                        <div style="max-width: 320px; font-family: 'Segoe UI', system-ui, sans-serif;">
                            <div style="display: flex; align-items: center; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid ${routeColor};">
                                <div style="width: 12px; height: 12px; background: ${routeColor}; border-radius: 2px; margin-right: 8px; box-shadow: 0 0 4px rgba(0,0,0,0.2);"></div>
                                <h3 style="margin: 0; color: ${routeColor}; font-size: 16px;">${props['Mapper Name'] || 'Mapper'}</h3>
                            </div>
                            <div style="background: #f8fafc; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                                ${props['OBJECTID'] ? `<div style="margin-bottom: 6px;"><span style="color: #64748b; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Object ID</span><br><strong style="color: #1e293b;">${props['OBJECTID']}</strong></div>` : ''}
                                ${props['MOBILEPAY_ZONE'] ? `<div style="margin-bottom: 6px;"><span style="color: #64748b; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Mobile Pay Zone</span><br><strong style="color: #1e293b;">${props['MOBILEPAY_ZONE']}</strong></div>` : ''}
                                ${props['Street View Spaces'] ? `<div style="margin-bottom: 6px;"><span style="color: #64748b; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Street View Spaces</span><br><strong style="color: #1e293b;">${props['Street View Spaces']}</strong></div>` : ''}
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
                                <div style="background: white; padding: 8px; border-radius: 6px; border: 1px solid #e2e8f0;">
                                    <div style="color: #64748b; font-size: 11px; margin-bottom: 2px;">TYPE</div>
                                    <div style="font-weight: 600; color: #1e293b;">${geometryType === 'MultiLineString' ? 'Multi-segment' : 'Simple'}</div>
                                </div>
                                <div style="background: white; padding: 8px; border-radius: 6px; border: 1px solid #e2e8f0;">
                                    <div style="color: #64748b; font-size: 11px; margin-bottom: 2px;">POINTS</div>
                                    <div style="font-weight: 600; color: #1e293b;">${props.coordinateCount || 'N/A'}</div>
                                </div>
                                ${props.segmentCount ? `
                                <div style="background: white; padding: 8px; border-radius: 6px; border: 1px solid #e2e8f0;">
                                    <div style="color: #64748b; font-size: 11px; margin-bottom: 2px;">SEGMENTS</div>
                                    <div style="font-weight: 600; color: #1e293b;">${props.segmentCount}</div>
                                </div>` : ''}
                                ${props.formattedDistance ? `
                                <div style="background: linear-gradient(135deg, ${routeColor}15, ${routeColor}05); padding: 8px; border-radius: 6px; border: 1px solid ${routeColor}30;">
                                    <div style="color: ${routeColor}; font-size: 11px; margin-bottom: 2px;">DISTANCE</div>
                                    <div style="font-weight: 700; color: ${routeColor}; font-size: 14px;">${props.formattedDistance}</div>
                                </div>` : ''}
                            </div>
                        </div>
                    `;
                    
                    new mapboxgl.Popup({
                        closeButton: true,
                        closeOnClick: false,
                        maxWidth: '340px',
                        className: 'custom-popup'
                    })
                        .setLngLat(e.lngLat)
                        .setHTML(content)
                        .addTo(map);
                });

                // Change cursor on hover
                map.on('mouseenter', 'routes', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });

                map.on('mouseleave', 'routes', () => {
                    map.getCanvas().style.cursor = '';
                });
            }

            // Add point features as enhanced markers
            pointFeatures.forEach((feature, index) => {
                const marker = new mapboxgl.Marker({
                    color: '#dc2626',
                    scale: 1.2
                })
                .setLngLat(feature.geometry.coordinates)
                .setPopup(new mapboxgl.Popup({
                    closeButton: true,
                    closeOnClick: false,
                    maxWidth: '300px',
                    className: 'custom-popup'
                }).setHTML(`
                    <div style="max-width: 280px; font-family: 'Segoe UI', system-ui, sans-serif;">
                        <div style="display: flex; align-items: center; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #dc2626;">
                            <div style="width: 12px; height: 12px; background: #dc2626; border-radius: 50%; margin-right: 8px; box-shadow: 0 0 4px rgba(220, 38, 38, 0.3);"></div>
                            <h3 style="margin: 0; color: #dc2626; font-size: 16px;">${feature.properties['Mapper Name'] || 'Mapper'}</h3>
                        </div>
                        <div style="background: #fef2f2; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                            ${feature.properties['OBJECTID'] ? `<div style="margin-bottom: 6px;"><span style="color: #991b1b; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Object ID</span><br><strong style="color: #7f1d1d;">${feature.properties['OBJECTID']}</strong></div>` : ''}
                            ${feature.properties['MOBILEPAY_ZONE'] ? `<div style="margin-bottom: 6px;"><span style="color: #991b1b; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Mobile Pay Zone</span><br><strong style="color: #7f1d1d;">${feature.properties['MOBILEPAY_ZONE']}</strong></div>` : ''}
                            ${feature.properties['Street View Spaces'] ? `<div style="margin-bottom: 6px;"><span style="color: #991b1b; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Street View Spaces</span><br><strong style="color: #7f1d1d;">${feature.properties['Street View Spaces']}</strong></div>` : ''}
                        </div>
                        <div style="background: linear-gradient(135deg, #dc262615, #dc262605); padding: 8px; border-radius: 6px; border: 1px solid #dc262630; text-align: center;">
                            <div style="color: #dc2626; font-size: 11px; margin-bottom: 2px;">TYPE</div>
                            <div style="font-weight: 700; color: #dc2626; font-size: 14px;">üìç Point Location</div>
                        </div>
                    </div>
                `))
                .addTo(map);
                
                loadedFeatures.push(marker);
            });

            // Fit map to show all features with improved animation
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, {
                    padding: { top: 60, bottom: 60, left: 60, right: 60 },
                    maxZoom: 16,
                    duration: 1500, // Smooth animation
                    essential: true // Animation won't be interrupted
                });
            }

            return featureCount;
        }

        // Load GeoJSON data from Google Sheets
        async function loadGeoJSONData() {
            const sheetUrl = document.getElementById('sheetUrl').value;
            const loadBtn = document.querySelector('.btn');
            const loadBtnText = document.getElementById('loadBtnText');
            
            if (!sheetUrl) {
                showStatus('Please enter a Google Sheets URL', 'error');
                return;
            }

            const sheetId = extractSheetId(sheetUrl);
            if (!sheetId) {
                showStatus('Invalid Google Sheets URL', 'error');
                return;
            }

            try {
                loadBtn.disabled = true;
                loadBtnText.innerHTML = '<div class="loading-spinner"></div>Loading...';
                showStatus('Fetching data from Google Sheets...', 'loading');

                // Clear existing features
                clearMap();

                // Google Sheets CSV export URL
                const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
                console.log('Fetching from URL:', csvUrl);
                
                const response = await fetch(csvUrl);
                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                if (!response.ok) {
                    throw new Error(`Failed to fetch data: ${response.status}`);
                }

                const csvText = await response.text();
                console.log('Raw CSV data (first 1000 chars):', csvText.substring(0, 1000));
                console.log('CSV length:', csvText.length);
                
                // Check if we actually got CSV data or an error page
                if (csvText.includes('<html>') || csvText.includes('<!DOCTYPE')) {
                    throw new Error('Received HTML instead of CSV data. Make sure the Google Sheet is publicly accessible.');
                }
                
                // Parse CSV with better handling and performance optimization
                const rows = csvText.split('\n').map((row, rowIndex) => {
                    if (!row.trim()) return []; // Skip empty rows
                    
                    console.log(`Raw row ${rowIndex}:`, row);
                    
                    // Simple CSV parsing (handles basic cases)
                    const cells = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let i = 0; i < row.length; i++) {
                        const char = row[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            cells.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    cells.push(current.trim());
                    
                    console.log(`CSV Row ${rowIndex} parsed into ${cells.length} cells:`, cells);
                    return cells.filter(cell => cell.length > 0); // Remove empty cells
                }).filter(row => row.length > 0); // Remove empty rows
                
                console.log(`Total rows after filtering: ${rows.length}`);
                console.log('Sample of first few rows:', rows.slice(0, 3));

                showStatus('Parsing GeoJSON data...', 'loading');
                
                const features = parseGeoJSONFromRows(rows);
                
                if (features.length === 0) {
                    showStatus('No valid GeoJSON features found in the sheet', 'error');
                    return;
                }

                // Store all features for filtering
                allFeatures = features;
                
                // Populate filter dropdowns
                populateFilters(features);

                showStatus('Adding features to map...', 'loading');
                
                const featureCount = addFeaturesToMap(features);
                
                showStatus(`Successfully loaded ${featureCount} features!`, 'success');
                
                // Show legend
                document.getElementById('legend').style.display = 'block';
                document.getElementById('clearBtn').disabled = false;

            } catch (error) {
                console.error('Error loading data:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                loadBtn.disabled = false;
                loadBtnText.textContent = 'Load & Visualize Data';
            }
        }

        // Clear all features from Mapbox map
        function clearMap() {
            // Remove markers
            loadedFeatures.forEach(marker => {
                marker.remove();
            });
            loadedFeatures = [];
            allFeatures = [];
            
            // Remove line layers and sources
            if (map.getLayer('routes')) {
                map.removeLayer('routes');
            }
            if (map.getLayer('routes-outline')) {
                map.removeLayer('routes-outline');
            }
            if (map.getSource('routes')) {
                map.removeSource('routes');
            }
            
            // Clear filters
            document.getElementById('filterMapper').innerHTML = '<option value="">All Mappers</option>';
            document.getElementById('filterZone').innerHTML = '<option value="">All Zones</option>';
            document.getElementById('searchObjectId').value = '';
            
            currentFilters = {
                mapper: '',
                zone: '',
                searchObjectId: ''
            };
            
            document.getElementById('legend').style.display = 'none';
            document.getElementById('clearBtn').disabled = true;
        }

        // Handle Enter key in input
        document.getElementById('sheetUrl').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loadGeoJSONData();
            }
        });

        // Populate filter dropdowns
        function populateFilters(features) {
            const mappers = new Set();
            const zones = new Set();
            
            features.forEach(feature => {
                const props = feature.properties;
                if (props['Mapper Name']) mappers.add(props['Mapper Name']);
                if (props['MOBILEPAY_ZONE']) zones.add(props['MOBILEPAY_ZONE']);
            });
            
            // Populate mapper dropdown
            const mapperSelect = document.getElementById('filterMapper');
            mapperSelect.innerHTML = '<option value="">All Mappers</option>';
            Array.from(mappers).sort().forEach(mapper => {
                const option = document.createElement('option');
                option.value = mapper;
                option.textContent = mapper;
                mapperSelect.appendChild(option);
            });
            
            // Populate zone dropdown
            const zoneSelect = document.getElementById('filterZone');
            zoneSelect.innerHTML = '<option value="">All Zones</option>';
            Array.from(zones).sort((a, b) => a - b).forEach(zone => {
                const option = document.createElement('option');
                option.value = zone;
                option.textContent = zone;
                zoneSelect.appendChild(option);
            });
        }

        // Filter features based on current filters
        function getFilteredFeatures() {
            return allFeatures.filter(feature => {
                const props = feature.properties;
                
                // Mapper filter
                if (currentFilters.mapper && props['Mapper Name'] !== currentFilters.mapper) {
                    return false;
                }
                
                // Zone filter
                if (currentFilters.zone && props['MOBILEPAY_ZONE'] !== currentFilters.zone) {
                    return false;
                }
                
                // Object ID search
                if (currentFilters.searchObjectId && 
                    !props['OBJECTID'].toString().includes(currentFilters.searchObjectId)) {
                    return false;
                }
                
                return true;
            });
        }

        // Apply filters to map
        function applyFilters() {
            currentFilters.mapper = document.getElementById('filterMapper').value;
            currentFilters.zone = document.getElementById('filterZone').value;
            
            updateMapWithFilters();
        }

        // Search for Object ID
        function searchObjectId() {
            currentFilters.searchObjectId = document.getElementById('searchObjectId').value.trim();
            updateMapWithFilters();
        }

        // Handle Enter key press in search
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchObjectId();
            }
        }

        // Update map with filtered features
        function updateMapWithFilters() {
            // Clear existing features
            clearMapFeatures();
            
            // Get filtered features
            const filteredFeatures = getFilteredFeatures();
            
            // Add filtered features to map
            if (filteredFeatures.length > 0) {
                addFeaturesToMap(filteredFeatures);
                showStatus(`Showing ${filteredFeatures.length} of ${allFeatures.length} features`, 'success');
                document.getElementById('legend').style.display = 'block';
                document.getElementById('clearBtn').disabled = false;
            } else {
                showStatus('No features match the current filters', 'error');
                document.getElementById('legend').style.display = 'none';
            }
        }

        // Clear only map features (for filtering), not the filter dropdowns
        function clearMapFeatures() {
            // Remove markers
            loadedFeatures.forEach(marker => {
                marker.remove();
            });
            loadedFeatures = [];
            
            // Remove line layers and sources
            if (map.getLayer('routes')) {
                map.removeLayer('routes');
            }
            if (map.getLayer('routes-outline')) {
                map.removeLayer('routes-outline');
            }
            if (map.getSource('routes')) {
                map.removeSource('routes');
            }
        }

        // Clear all filters
        function clearFilters() {
            document.getElementById('filterMapper').value = '';
            document.getElementById('filterZone').value = '';
            document.getElementById('searchObjectId').value = '';
            
            currentFilters = {
                mapper: '',
                zone: '',
                searchObjectId: ''
            };
            
            // Show all features
            if (allFeatures.length > 0) {
                clearMapFeatures();
                addFeaturesToMap(allFeatures);
                showStatus(`Showing all ${allFeatures.length} features`, 'success');
            }
        }

        // Change map style
        function changeMapStyle() {
            const styleSelect = document.getElementById('mapStyle');
            const selectedStyle = styleSelect.value;
            map.setStyle(`mapbox://styles/mapbox/${selectedStyle}`);
            
            // Re-add data sources and layers after style change
            map.once('styledata', () => {
                if (allFeatures.length > 0) {
                    // Small delay to ensure style is fully loaded
                    setTimeout(() => {
                        updateMapWithFilters();
                    }, 100);
                }
            });
        }

        // Initialize map when DOM is loaded
        document.addEventListener('DOMContentLoaded', initMap);
    </script>

    <!-- Mapbox GL JS -->
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
</body>
</html>
